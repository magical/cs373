---
layout: post
title: "Week 2: Computer Forensics"
draft: true
---

Week 2: Forensics
=================

This week we dip our toes into _forensics_!
I'll start by covering some basic concepts and then we'll use those concepts
to analyze a USB stick.

First things first
------------------




Impartiality
------------

When doing forensics, try to be impartial.
Don't assume the guilt or innocence of whatever party you're investigating.
Your primary job as an investigator is to accumulate evidence.


Locard's exchange principle
---------------------------


Locard’s exchange principle:

> Every interaction leaves evidence.


Dr. Edmond Locard was a French criminologist who lived roughly a century ago.
I'm paraphrasing because the original quote was in French and I can't find an
original source.

This is (apparently) the underlying principle of all modern forensics.

I'm slightly skeptical of this principle when it comes to computers,
but as we'll see in the rest of this post, there are plenty of cases where it applies.

Corollary: since the investigator has to interact with things to investigate them,
the investigator also leaves evidence. Thus, one of your most important duties as a
forensics investigator is to document every single action you take in the course of an
investigation, so that clean evidence can be separated out from compromised evidence.

We can also read Locard's principle as
a reforumulation of the observer effect in quantum mechanics.
Whoaaaaaaaa.

Volatility
----------

The general rule for beginning a forensic investigation is to
_collect the most volatile data first_.

It turns out there's a fscking RFC for this: [RFC3227][],
published Feb 2002.

[RFC3227]: https://tools.ietf.org/html/rfc3227

1. memory
2. hibernation file
3. temp files
4. process tables, network connections
5. network routing info, arp cache

    a. it is now safe to turn off your computer

That covers the stuff that won't persist across a reboot.
Continuing with less volatile state we have:

6. disks (with forensic tools, write blocker)
7. remote logging (cameras)
8. physical configuration & network topology
9. backups
    a. caveat: tape backups are very time consuming to work with


Volatility (redux)
------------------

Let's talk about memory dumps.
There is a handy open source tool for analyzing memory dumps which,
just to make things confusing,
is also called [volatility][].

I'm going to briefly explain the bits that we went over in class.
If you want to learn more you are welcome to read the [documentation][]
or the [cheat sheet][].


[volatility]: http://www.volatilityfoundation.org/
[documentation]: https://github.com/volatilityfoundation/volatility/wiki
[cheat sheet]: https://downloads.volatilityfoundation.org//releases/2.4/CheatSheet_v2.4.pdf


1. `volatility -f memory_dump.mem imageinfo`

First and foremost, if you find yourself in posession of a strange memory dump,
the first thing you'll want to do is run `imageinfo` on it to find out what kind of system it's from. This will spit out something like `suggested profiles: WinSP0x86`. Copy that string into the rest of these commands.

2. `volatility -f memory_dump.mem --profile=WinSP0x86 psscan`

`psscan` prints a list of proceses that were running at the time of the memory dump.

3. `volatility -f memory_dump.mem --profile=WinSP0x86 dlllist -p 1234`

Given a process ID, `dlllist` will tell you what DLLs a process had loaded.

4. `volalility -f memory_dump.mem --profile=WinSP0x86 mftparser`

This is a cool one. It reads the master file table block to
give you a list of the files on the filesystem.
(What's the MFT doing in a memory dump? It must be cached in memory somewhere.)

5. `volatility -f memory_dump.mem --profile=WinSP0x86 timeliner --output=dump`

This is another cool one. `timeliner` prints out a timeline of everything that happend on the system (everything still in memory, anyway). Running processes, filesystem events, etc. It's all here.

[insert screenshot]

### Aside: making memory dumps

There are several tools for capturing memory dumps.
In class, the tool we used was [FTK Imager][].

Bear in mind that the very act of running a memory dumper affect the memory of the system —
the memory dumper will show up in the process list in the dump.

When capturing a memory dump, do not write it to hard disk of the system you're
dumping. Dump to an external hard drive. We'll be capturing the disk image next.


Data recovery
-------------

That covers recovering data from memory, but what about data from disk?

* buy a write blocker device
* image the disk with something

toolkit: write-protected cdrom or usb stick
never ever install tools on a suspect machine - compromised evidence

If you're even slightly computer-saavy, you probably know that when you delete a file,
the file doesn't disappear right away. The inode in the file system is removed, but the contents of the file linger around on the disk in unused blocks.

The act of looking at unused blocks on a disk and piecing together deleted files from them
is known as "carving". Don't ask me why.

The tool we used in class was [PhotoRec][], which is free, open source (GPLv2), and cross-platform.

[PhotoRec]: https://www.cgsecurity.org/wiki/PhotoRec

We'll see PhotoRec in action in the next section, so I won't say much about it just yet.


Tips
----

1. Write everything down. Document everything.
Note down what time you did everything.


The Challenge
-------------

We were given a challenge in class to investigate a dump of a USB drive.

Following best practices, I tried to keep track of timestamps as I went.

The following events took place mostly on Mon Jan 22nd.

**17:00** First, I tried analyzing the USB image data with volatility imageinfo.
Volatility didn’t recognize anything - makes sense, since we are told
this is a disk dump rather than a memory dump.

If i were doing this on linux, the first thing I would have done is run `file`
on the disk image to see if it was recognized as any known file type, but i'm
not so i just have to guess.

**17:09** Next step, mount the image with [OSFMount][] and poke around.
On linux, you would use `losetup` to mount the images as a loopback device.

[OSFMount]: https://www.osforensics.com/tools/mount-disk-images.html

Important: *make sure to mount the image read-only*.
We don't want to allow any modifications to happen to the image
and compromise the evidence.
Also, if any data gets accidentally written to the image, it will overwrite
free blocks that might have data from deleted files, which we want to be able to recover.

[osfmount screenshot]

There are 6 files, mostly with korean-looknig names
an .mp3, a jpg, a png, a bin, a bat, and a zip.

[file screenshot]

We’re going to ignore these for now and try to recover deleted files with PhotoRec.

[photorec screenshot]

Select the drive you want to carve, select the output directory. Pretty simple.

You can also limit which types of files PhotoRec should look for,
but I don't really know what I'm looking for so I just leave it at the default of *everything*.

**17:15** Photorec was successful! It recovered 8 files. Let's see if any of these are useful.

[file screenshot]

Note that the filenames are kind of garbage.
This is because the files were deleted, so all their metadata, including the filename, is gone.


Are any of these images helpful?

[image screenshots]

...Not really. The middle one is intriguing, but it doesn't mean anything to me right now.

This isn’t leading anywhere.
Let's go back and take a look at the files that hadn't been deleted.

**17:??** Tried to open the zip file. It contains a csv, but it's password protected. Rats.

Oh, this is interesting! One of the deleted files is a rar of some software named DuBrute.

Googling for DuBrute turns up this article:

    “DuBrute is a service that processes three text files in sequence: IP addresses, login names, and then passwords. Once running, it fires off logins and passwords until it exhausts the first IP address and repeats the process on down list one until the end. Cute and nasty.”

    – https://www.techrepublic.com/blog/it-security/around-the-world-in-ip-attacks/

There was also a `hosts.txt` file containing a bunch of ip addresses.
Someone was probably trying to brute-force a bunch of hosts.

**17:26** opened “fdd” in fileInsight. It’s an elf executable

**17:31** mounted the .apple file and ran photorec on it. no dice

**17:35** watched the video. it shows someone investigating a piece of malware in “RAPTOR” - some sort of network/threat monitoring software
a quick google doesn’t reveal any products under that name

---

At this point, I consulted the hints. They suggested I take a closer look at one of the jpeg images on the drive to find the password for the zip.

[fileinsight screenshot]

Bingo! I have no idea what this password string is doing in a jpeg.
It's probably in the EXIF data?


Conclusion
----------





Acknowledgements
-----

This post was based on lectures given by [Christiaan Beek][],
Lead Scientist & Principal Engineer at McAfee.

[Christiaan Beek]: https://twitter.com/ChristiaanBeek
