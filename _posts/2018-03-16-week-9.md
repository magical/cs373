---
title: "Weeks 9 & 10: Mobile Security"
layout: post
draft: true
---

Weeks 9 and 10: Mobile Security
====

Hello! This will be the last post in this series.
It's been a fun journey and I've learned a lot,
and i hope you have too.

This week is about mobile security.
Specifically, Android security.
We'll take a brief look at the history of the mobile as a platform for malware,
and then dive in for a hand-on look at some android malware.

----

History of phones

The current big players in the mobile space are Android and iOS.
Microsoft also made a bid into mobile with Windows Phone and later Windows Mobile, but
recently announced that they were [shuttering the project][goodbye].

[goodbye]: https://en.wikipedia.org/wiki/Windows_10_Mobile

It wasn't always like this. Before the iPhone came along, the three big players were Symbian, Palm, RIM (Blackberry).


---

Android malware

---


Anatomy of an APK
----


An android package is a zip file with a few major components:

- `AndroidManifest.xml`.
    This is where metadata about the app like its name and icon are defined.
  It's also where entrypoints for the app are defined: things like _activities_ (UI screens) and
  background services.
- `classes.dex`.
  This is an archive of the compiled java code
- `can also have native code

At first Android apps were Java-only;
there was no way to write apps that used native code.

[lawsuit]: https://www.eff.org/cases/oracle-v-google

Dalvik was Google's custom implementation of the Java virtual machine,
created partially so it could be optimized for embedded devices,
and partially to get around licensing issues.
([Oracle famously sued anyway][lawsuit].)

Eventually support for native code was added, Dalvik was deprecated,
and Android 5.0 finally jettisoned Dalvik support altogether.
APK files can still include a classes.dex file to support older devices,
but I'm sure even that will fall by the wayside soon.


Analysis tools
------

# Static analysis

- apk
- dex2jar

One of the nice things about Android apps being primarily written in Java
is that Java is really easy to decompile. Unlike compiled languages like
C++, compiled java code still contains all the identifiers from the original program.
Class names, method names, package names, variable names, you name it.
Not only that, Java bytecode is higher-level than assembly code, so it
is easier to recover control structures.
All in all, it's way easier to recover decent-looking Java code.
There are even some good open source tools!

- [JD-gui](http://jd.benow.ca/) is an open-source Java decompiler.
  It's the most basic of the decompilers listed here, but it's still pretty good.
  It wasn't built for Android analysis though, so you have to massage things back into a format that understands.

- [Jadx](https://github.com/skylot/jadx) is another open-source decompiler.
  The nice thing about Jadx is that it can directly open `classes.dex` files and APK files.

- JED is a commercial decompiler. It has a lot of tools for analyzing obfuscated code,
  but it costs a fortune.

# Dynamic analysis

- Emulators, emulators, emulators

The Android developer kit comes with a high-quality emulator,
since it's not really reasonable to expect developers to install an app to their phone
every time they want to test something.

This is great for us because it gives us a relatively safe environment to test malware out in.


Obfuscation tricks
----

- identifier renaming
- string encryption
- manifest obfuscation (fixed)
- tricking the decompiler

Obfuscation tools
----

- DexGuard
- ProGuard





Obad
----

Let's look at an actual piece of android malware.

When it was released in 2014, Obad was called the [most complex piece of android malware in existence][obad].
Let's find out why.

[obad]: https://securityintelligence.com/diy-android-malware-analysis-taking-apart-obad-part-1/


Bootkits
------

I want to briefly talk about Android bootkits.
As we talked about in week 5, 
a [bootkit][] is a type of malware that runs very early in the boot sequence of the computer,
before the operating system starts,
typically by installing itself in the master boot record or even earlier.

The first known Android bootkit was discovered in 2014
The Android boot process works a little differently than a PC, so the bootkit works a little differently as well.
Oldboot is actually installed as a system process, `/sbin/imei_chk`,
which is launched on boot by a line the Android boot script, `/init.rc`
Its payload is an app called "GoogleKernel". You can try to remove it,
but the bootkit will just reinstall on the next boot if it ever gets removed.

These files are located in the *read-only* partition of the Android device,
where all the other important Android operating system components are found.
The only way to remove the bootkit, short of performing a jailbreak,
is to reinstall the whole OS.


The most fascinating thing about Oldboot is that it was found
*preinstalled* on certain Android devices from China â€“
and that's the *only* known distribution method.
It isn't something that could get infected with on a previously clean device,
either your device came with Oldboot on it or it didn't.


Conclusion
-----

Out of all the stuff we've covered, this section is probably the least likely to stay relevant.
Ten years ago, Android barely existed and the mobile malware landscape looked completely different.
Even as I write this post, most of the Java-based stuff we covered is on the verge of being obsoleted
by native apps, and the rest will probabably be obsolete in another 10 years.


Wrap-up
-------

I want to take a moment to look back and reflect on this series as a whole.
In just 10 short weeks we've covered

- Malware: basics, definitions and defense.
  We looked at how antivirus software works, where its weak points are,
  and tried writing our own virus detection rules
  - we analyzed the behaviour of some real malware samples
  - static and dynamic analysis
- Exploits: how to turn a vulnerability like a buffer overflow into an actual attack
- Forensics: the basics of what a forensic investigator does, and how to
  recover files and information from a memory dump or disk image
- Rootkits: how they work (hooking) / how to detect and defend against them
  we analyzed a real rootkit
- Web security: we looked at a couple common web attacks and tried our hands at URL classification
- Spam: we looked at how spam messages propaate, and how mail providers automatically
  flag spam messages and prevent them from reaching your inbox


Common themes:
- Social engineering has been a constant theme. I don't think there was a single
  week when it wasn't mentioned. 


Acknowledgements
----

This post was based on lecures given by
[Fernando Ruiz](https://securingtomorrow.mcafee.com/author/fernando-ruiz/)
of McAfee Labs.
