---
title: "Week 7: Web Security"
layout: post
draft: true
---


Week 7: Web Security
====================

Welcome to week 7 of this series. Astute readers may notice that the last
post was [week 5][]. What happened to week 6? Well, it was kind of
dull so I decided not to blog about it. You're welcome.

This week we're talking about web security.

[week 5]: https://magical.github.io/cs373/2018/02/13/week-5

---

When we say "web security" we basically mean "browser security".
web security is important because more and more of our daily lives
happen on the web – you probably check your bank account online, for example.

Traditional software is fading away and being replaced by web apps.
Browsers are subsuming more and more of the capabilities of the operating system,
leaving apps with less incentive to go native.

(It's hilarious to watch brower vendors relearn UI lessons that desktop OSs learned decades ago.
Things like modal dialogs and window management.)

This isn't limited to just legitimate programs –
some modern malware doesn't even try to leave the browser either.
It's happy to just live in your browser and sniff all your web traffic
and not even go to the effort of trying to leverage a browser exploit to leap
onto the underlying OS.
This has advantages for avoiding detection – as i believe we touched on earlier,
most antivirus software is based on file scanning.
If a piece of malware exists only on a webpage, there's no file on your computer to scan.



---

When we think of securing the browser, we usually think of defending it *from*
the web.
But we can't overlook the threats from the other side.

- toolbars
- flash, java
- superfish




User security
----



- robin sage (social media attacks)


Application security
---


###SQL injection

We discussed SQL injection. I don't have anything to say here that hasn't been covered to death already by a million of online tutorials.
No modern web apps should be vulnerable to SQL injection.
Use parameterized queries.


###XSS

We also discussed XSS, briefly. This is the same category of attack as SQL injection:
someone pasted user input into raw HTML without escaping it.

If you want to avoid SQL injection, XSS, and this entire class of vulnerability,
[read this][eevee] and internalize it:

> A common suggestion is "sanitizing" your input. If someone tells you to do this, punch that person in the face [...]. If you sanitize input, you will almost certainly fuck up legitimate data and still miss a few edge cases. Evil data doesn't need to be "de-eviled"; it needs to be passed across interfaces safely.
> What's an interface? Anywhere two different layers stick together. There's an interface between your program code and your SQL. There's an interface between your Web server and your program. There's an interface between your data and the HTML you generate. Anytime two systems interact, data needs to be transformed from one to the other. The most common security problems arise because the programmer figures "well usernames are just letters" and dumps some mystery data directly into a template or query or whatever.


[eevee]: https://eevee.livejournal.com/330586.html



### Web goat

If you want to play around with web exploits yourself, maybe check out
the [web goat][] - an intentionally vulnerable tutorial-type program that walks
you through exploiting a variety of common vulnerabilities, including XSS
and SQL injection.

On the other hand, it's written in Java so maybe pass.

### SQLiX

It turned out that the lecturer this week was one of the authors of [SQLiX],
a perl program for automatically exploiting SQL injection bugs.
It can do crazy things like identify the type and version of the SQL server that
is running (i.e. MySQL, SQL Server, etc)
and perform *blind SQL injection*, which is where you are able to execute arbitrary
SQL code but *can't see the results* –
the trick is apparently to exfiltrate the data one bit at a time based on whether
you trigger an error or not.

[SQLiX]: https://www.owasp.org/index.php/Category:OWASP_SQLiX_Project


URL classification
------------------

We dipped our toes into URL classification.
Specifically, content-agnostic URL classification, where we look only at the URL and not actually at any of the page content.

How odes this work? It turns out that malicious uURLS have a lot in common.
For example, most phishing sites try to make their url look similar to the target site in predictable ways

e.g.

    eu.battle.net.blizzardentertainmentfreeofactivitiese.com

is a phishing url for blizzard's battle.net.

When trying to come up with rules, my main goal was to avoid false positives.
False positives are a big no-no in this sort of automated scanning
because of the "boy who cried wolf" effect –
if your security tool constantly flags benign sites as dangerous,
users will learn to ignore it, or maybe even disable it entirely.


I also added a rule which gave a boost to well-known tlds like .com, .net, .org, and gave a penalty to tlds like .ru (russia) and .vu (vanuatu).
This is dangerous territory because now we're discriminating based purely on the country that a domain was registered in – a very weak indicator.
Yes there are lots of spam domains with a .ru, but there are plenty of legitimate .ru domains as well.

One reason this works is that people browsing in the US will rarely if ever visit a Russian domain, even a legitimate one.
But presumably people living in russia visit Russian domains more frequently; that is, we can expect statistics about TLD frequency to vary by country.

Acknowledgements
----------------

This post is based off of lecures given by
[Cedric Cochin][] of McAfee Labs.

[Cedric Cochin]: https://www.linkedin.com/in/cochin
